{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StateClient = void 0;\nconst eventemitter3_1 = __importDefault(require(\"eventemitter3\"));\nconst camelcase_1 = __importDefault(require(\"camelcase\"));\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst provider_js_1 = require(\"../../provider.js\");\nconst index_js_1 = require(\"../../coder/index.js\");\nconst common_js_1 = require(\"../common.js\");\nconst pubkey_js_1 = require(\"../../utils/pubkey.js\");\nconst instruction_js_1 = __importDefault(require(\"./instruction.js\"));\nconst rpc_js_1 = __importDefault(require(\"./rpc.js\"));\nconst transaction_js_1 = __importDefault(require(\"./transaction.js\"));\nclass StateFactory {\n  static build(idl, coder, programId, provider) {\n    if (idl.state === undefined) {\n      return undefined;\n    }\n    return new StateClient(idl, programId, provider, coder);\n  }\n}\nexports.default = StateFactory;\n/**\n * A client for the program state. Similar to the base [[Program]] client,\n * one can use this to send transactions and read accounts for the state\n * abstraction.\n */\nclass StateClient {\n  constructor(idl, programId) {\n    let provider = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (0, provider_js_1.getProvider)();\n    let coder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new index_js_1.BorshCoder(idl);\n    this.provider = provider;\n    this.coder = coder;\n    this._idl = idl;\n    this._programId = programId;\n    this._address = programStateAddress(programId);\n    this._sub = null;\n    // Build namespaces.\n    const [instruction, transaction, rpc] = (() => {\n      var _a;\n      let instruction = {};\n      let transaction = {};\n      let rpc = {};\n      (_a = idl.state) === null || _a === void 0 ? void 0 : _a.methods.forEach(m => {\n        // Build instruction method.\n        const ixItem = instruction_js_1.default.build(m, (ixName, ix) => coder.instruction.encodeState(ixName, ix), programId);\n        ixItem[\"accounts\"] = accounts => {\n          const keys = stateInstructionKeys(programId, provider, m, accounts);\n          return keys.concat(instruction_js_1.default.accountsArray(accounts, m.accounts, m.name));\n        };\n        // Build transaction method.\n        const txItem = transaction_js_1.default.build(m, ixItem);\n        // Build RPC method.\n        const rpcItem = rpc_js_1.default.build(m, txItem, (0, common_js_1.parseIdlErrors)(idl), provider);\n        // Attach them all to their respective namespaces.\n        const name = (0, camelcase_1.default)(m.name);\n        instruction[name] = ixItem;\n        transaction[name] = txItem;\n        rpc[name] = rpcItem;\n      });\n      return [instruction, transaction, rpc];\n    })();\n    this.instruction = instruction;\n    this.transaction = transaction;\n    this.rpc = rpc;\n  }\n  /**\n   * Returns the program ID owning the state.\n   */\n  get programId() {\n    return this._programId;\n  }\n  /**\n   * Returns the deserialized state account.\n   */\n  async fetch() {\n    const addr = this.address();\n    const accountInfo = await this.provider.connection.getAccountInfo(addr);\n    if (accountInfo === null) {\n      throw new Error(`Account does not exist ${addr.toString()}`);\n    }\n    // Assert the account discriminator is correct.\n    const state = this._idl.state;\n    if (!state) {\n      throw new Error(\"State is not specified in IDL.\");\n    }\n    const expectedDiscriminator = await (0, index_js_1.stateDiscriminator)(state.struct.name);\n    if (expectedDiscriminator.compare(accountInfo.data.slice(0, 8))) {\n      throw new Error(\"Invalid account discriminator\");\n    }\n    return this.coder.state.decode(accountInfo.data);\n  }\n  /**\n   * Returns the state address.\n   */\n  address() {\n    return this._address;\n  }\n  /**\n   * Returns an `EventEmitter` with a `\"change\"` event that's fired whenever\n   * the state account cahnges.\n   */\n  subscribe(commitment) {\n    if (this._sub !== null) {\n      return this._sub.ee;\n    }\n    const ee = new eventemitter3_1.default();\n    const listener = this.provider.connection.onAccountChange(this.address(), acc => {\n      const account = this.coder.state.decode(acc.data);\n      ee.emit(\"change\", account);\n    }, commitment);\n    this._sub = {\n      ee,\n      listener\n    };\n    return ee;\n  }\n  /**\n   * Unsubscribes to state changes.\n   */\n  unsubscribe() {\n    if (this._sub !== null) {\n      this.provider.connection.removeAccountChangeListener(this._sub.listener).then(async () => {\n        this._sub = null;\n      }).catch(console.error);\n    }\n  }\n}\nexports.StateClient = StateClient;\n// Calculates the deterministic address of the program's \"state\" account.\nfunction programStateAddress(programId) {\n  let [registrySigner] = (0, pubkey_js_1.findProgramAddressSync)([], programId);\n  return (0, pubkey_js_1.createWithSeedSync)(registrySigner, \"unversioned\", programId);\n}\n// Returns the common keys that are prepended to all instructions targeting\n// the \"state\" of a program.\nfunction stateInstructionKeys(programId, provider, m, accounts) {\n  if (m.name === \"new\") {\n    // Ctor `new` method.\n    const [programSigner] = (0, pubkey_js_1.findProgramAddressSync)([], programId);\n    // @ts-expect-error\n    if (provider.wallet === undefined) {\n      throw new Error(\"This function requires the Provider interface implementor to have a 'wallet' field.\");\n    }\n    return [{\n      // @ts-expect-error\n      pubkey: provider.wallet.publicKey,\n      isWritable: false,\n      isSigner: true\n    }, {\n      pubkey: programStateAddress(programId),\n      isWritable: true,\n      isSigner: false\n    }, {\n      pubkey: programSigner,\n      isWritable: false,\n      isSigner: false\n    }, {\n      pubkey: web3_js_1.SystemProgram.programId,\n      isWritable: false,\n      isSigner: false\n    }, {\n      pubkey: programId,\n      isWritable: false,\n      isSigner: false\n    }];\n  } else {\n    (0, common_js_1.validateAccounts)(m.accounts, accounts);\n    return [{\n      pubkey: programStateAddress(programId),\n      isWritable: true,\n      isSigner: false\n    }];\n  }\n}","map":{"version":3,"mappings":"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","names":["StateFactory","build","idl","coder","programId","provider","state","undefined","StateClient","exports","constructor","index_js_1","_idl","_programId","_address","programStateAddress","_sub","instruction","transaction","rpc","methods","forEach","m","ixItem","instruction_js_1","ixName","ix","encodeState","accounts","keys","stateInstructionKeys","concat","accountsArray","name","txItem","transaction_js_1","rpcItem","rpc_js_1","fetch","addr","address","accountInfo","connection","getAccountInfo","Error","toString","expectedDiscriminator","struct","compare","data","slice","decode","subscribe","commitment","ee","eventemitter3_1","listener","onAccountChange","acc","account","emit","unsubscribe","removeAccountChangeListener","then","catch","console","error","registrySigner","programSigner","wallet","pubkey","publicKey","isWritable","isSigner","web3_js_1"],"sourceRoot":"","sources":["../../../../src/program/namespace/state.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}