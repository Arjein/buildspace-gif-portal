{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeIdlAccount = exports.decodeIdlAccount = exports.seed = exports.idlAddress = void 0;\nconst buffer_1 = require(\"buffer\");\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst borsh = __importStar(require(\"@project-serum/borsh\"));\n// Deterministic IDL address as a function of the program id.\nasync function idlAddress(programId) {\n  const base = (await web3_js_1.PublicKey.findProgramAddress([], programId))[0];\n  return await web3_js_1.PublicKey.createWithSeed(base, seed(), programId);\n}\nexports.idlAddress = idlAddress;\n// Seed for generating the idlAddress.\nfunction seed() {\n  return \"anchor:idl\";\n}\nexports.seed = seed;\nconst IDL_ACCOUNT_LAYOUT = borsh.struct([borsh.publicKey(\"authority\"), borsh.vecU8(\"data\")]);\nfunction decodeIdlAccount(data) {\n  return IDL_ACCOUNT_LAYOUT.decode(data);\n}\nexports.decodeIdlAccount = decodeIdlAccount;\nfunction encodeIdlAccount(acc) {\n  const buffer = buffer_1.Buffer.alloc(1000); // TODO: use a tighter buffer.\n  const len = IDL_ACCOUNT_LAYOUT.encode(acc, buffer);\n  return buffer.slice(0, len);\n}\nexports.encodeIdlAccount = encodeIdlAccount;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AAuKA;AACO,eAAeA,UAAU,CAACC,SAAoB;EACnD,MAAMC,IAAI,GAAG,CAAC,MAAMC,mBAAS,CAACC,kBAAkB,CAAC,EAAE,EAAEH,SAAS,CAAC,EAAE,CAAC,CAAC;EACnE,OAAO,MAAME,mBAAS,CAACE,cAAc,CAACH,IAAI,EAAEI,IAAI,EAAE,EAAEL,SAAS,CAAC;AAChE;AAHAM;AAKA;AACA,SAAgBD,IAAI;EAClB,OAAO,YAAY;AACrB;AAFAC;AAUA,MAAMC,kBAAkB,GAAoCC,KAAK,CAACC,MAAM,CAAC,CACvED,KAAK,CAACE,SAAS,CAAC,WAAW,CAAC,EAC5BF,KAAK,CAACG,KAAK,CAAC,MAAM,CAAC,CACpB,CAAC;AAEF,SAAgBC,gBAAgB,CAACC,IAAY;EAC3C,OAAON,kBAAkB,CAACO,MAAM,CAACD,IAAI,CAAC;AACxC;AAFAP;AAIA,SAAgBS,gBAAgB,CAACC,GAAsB;EACrD,MAAMC,MAAM,GAAGC,eAAM,CAACC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;EACnC,MAAMC,GAAG,GAAGb,kBAAkB,CAACc,MAAM,CAACL,GAAG,EAAEC,MAAM,CAAC;EAClD,OAAOA,MAAM,CAACK,KAAK,CAAC,CAAC,EAAEF,GAAG,CAAC;AAC7B;AAJAd","names":["idlAddress","programId","base","web3_js_1","findProgramAddress","createWithSeed","seed","exports","IDL_ACCOUNT_LAYOUT","borsh","struct","publicKey","vecU8","decodeIdlAccount","data","decode","encodeIdlAccount","acc","buffer","buffer_1","alloc","len","encode","slice"],"sourceRoot":"","sources":["../../src/idl.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}