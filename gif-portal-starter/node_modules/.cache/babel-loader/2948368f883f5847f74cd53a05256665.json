{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BorshAccountsCoder = exports.ACCOUNT_DISCRIMINATOR_SIZE = void 0;\nconst bs58_1 = __importDefault(require(\"bs58\"));\nconst buffer_1 = require(\"buffer\");\nconst camelcase_1 = __importDefault(require(\"camelcase\"));\nconst js_sha256_1 = require(\"js-sha256\");\nconst idl_js_1 = require(\"./idl.js\");\nconst common_js_1 = require(\"../common.js\");\n/**\n * Number of bytes of the account discriminator.\n */\nexports.ACCOUNT_DISCRIMINATOR_SIZE = 8;\n/**\n * Encodes and decodes account objects.\n */\nclass BorshAccountsCoder {\n  constructor(idl) {\n    if (idl.accounts === undefined) {\n      this.accountLayouts = new Map();\n      return;\n    }\n    const layouts = idl.accounts.map(acc => {\n      return [acc.name, idl_js_1.IdlCoder.typeDefLayout(acc, idl.types)];\n    });\n    this.accountLayouts = new Map(layouts);\n    this.idl = idl;\n  }\n  async encode(accountName, account) {\n    const buffer = buffer_1.Buffer.alloc(1000); // TODO: use a tighter buffer.\n    const layout = this.accountLayouts.get(accountName);\n    if (!layout) {\n      throw new Error(`Unknown account: ${accountName}`);\n    }\n    const len = layout.encode(account, buffer);\n    let accountData = buffer.slice(0, len);\n    let discriminator = BorshAccountsCoder.accountDiscriminator(accountName);\n    return buffer_1.Buffer.concat([discriminator, accountData]);\n  }\n  decode(accountName, data) {\n    // Assert the account discriminator is correct.\n    const discriminator = BorshAccountsCoder.accountDiscriminator(accountName);\n    if (discriminator.compare(data.slice(0, 8))) {\n      throw new Error(\"Invalid account discriminator\");\n    }\n    return this.decodeUnchecked(accountName, data);\n  }\n  decodeUnchecked(accountName, ix) {\n    // Chop off the discriminator before decoding.\n    const data = ix.slice(exports.ACCOUNT_DISCRIMINATOR_SIZE);\n    const layout = this.accountLayouts.get(accountName);\n    if (!layout) {\n      throw new Error(`Unknown account: ${accountName}`);\n    }\n    return layout.decode(data);\n  }\n  memcmp(accountName, appendData) {\n    const discriminator = BorshAccountsCoder.accountDiscriminator(accountName);\n    return {\n      offset: 0,\n      bytes: bs58_1.default.encode(appendData ? buffer_1.Buffer.concat([discriminator, appendData]) : discriminator)\n    };\n  }\n  size(idlAccount) {\n    var _a;\n    return exports.ACCOUNT_DISCRIMINATOR_SIZE + ((_a = (0, common_js_1.accountSize)(this.idl, idlAccount)) !== null && _a !== void 0 ? _a : 0);\n  }\n  /**\n   * Calculates and returns a unique 8 byte discriminator prepended to all anchor accounts.\n   *\n   * @param name The name of the account to calculate the discriminator.\n   */\n  static accountDiscriminator(name) {\n    return buffer_1.Buffer.from(js_sha256_1.sha256.digest(`account:${(0, camelcase_1.default)(name, {\n      pascalCase: true\n    })}`)).slice(0, exports.ACCOUNT_DISCRIMINATOR_SIZE);\n  }\n}\nexports.BorshAccountsCoder = BorshAccountsCoder;","map":{"version":3,"mappings":"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","names":["exports","BorshAccountsCoder","constructor","idl","accounts","undefined","accountLayouts","Map","layouts","map","acc","name","idl_js_1","typeDefLayout","types","encode","accountName","account","buffer","buffer_1","alloc","layout","get","Error","len","accountData","slice","discriminator","accountDiscriminator","concat","decode","data","compare","decodeUnchecked","ix","memcmp","appendData","offset","bytes","bs58_1","size","idlAccount","from","js_sha256_1","digest","pascalCase"],"sourceRoot":"","sources":["../../../../src/coder/borsh/accounts.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}