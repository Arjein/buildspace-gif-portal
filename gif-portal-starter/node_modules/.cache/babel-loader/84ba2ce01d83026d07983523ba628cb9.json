{"ast":null,"code":"import camelCase from \"camelcase\";\nimport * as borsh from \"@project-serum/borsh\";\nimport * as bs58 from \"bs58\";\nimport { IdlCoder } from \"./idl\";\nimport { sighash } from \"./common\";\n/**\n * Namespace for state method function signatures.\n */\nexport const SIGHASH_STATE_NAMESPACE = \"state\";\n/**\n * Namespace for global instruction function signatures (i.e. functions\n * that aren't namespaced by the state or any of its trait implementations).\n */\nexport const SIGHASH_GLOBAL_NAMESPACE = \"global\";\n/**\n * Encodes and decodes program instructions.\n */\nexport class InstructionCoder {\n  constructor(idl) {\n    this.idl = idl;\n    this.ixLayout = InstructionCoder.parseIxLayout(idl);\n    const sighashLayouts = new Map();\n    idl.instructions.forEach(ix => {\n      const sh = sighash(SIGHASH_GLOBAL_NAMESPACE, ix.name);\n      sighashLayouts.set(bs58.encode(sh), {\n        layout: this.ixLayout.get(ix.name),\n        name: ix.name\n      });\n    });\n    if (idl.state) {\n      idl.state.methods.map(ix => {\n        const sh = sighash(SIGHASH_STATE_NAMESPACE, ix.name);\n        sighashLayouts.set(bs58.encode(sh), {\n          layout: this.ixLayout.get(ix.name),\n          name: ix.name\n        });\n      });\n    }\n    this.sighashLayouts = sighashLayouts;\n  }\n  /**\n   * Encodes a program instruction.\n   */\n  encode(ixName, ix) {\n    return this._encode(SIGHASH_GLOBAL_NAMESPACE, ixName, ix);\n  }\n  /**\n   * Encodes a program state instruction.\n   */\n  encodeState(ixName, ix) {\n    return this._encode(SIGHASH_STATE_NAMESPACE, ixName, ix);\n  }\n  _encode(nameSpace, ixName, ix) {\n    const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n    const methodName = camelCase(ixName);\n    const layout = this.ixLayout.get(methodName);\n    if (!layout) {\n      throw new Error(`Unknown method: ${methodName}`);\n    }\n    const len = layout.encode(ix, buffer);\n    const data = buffer.slice(0, len);\n    return Buffer.concat([sighash(nameSpace, ixName), data]);\n  }\n  static parseIxLayout(idl) {\n    const stateMethods = idl.state ? idl.state.methods : [];\n    const ixLayouts = stateMethods.map(m => {\n      let fieldLayouts = m.args.map(arg => {\n        var _a, _b;\n        return IdlCoder.fieldLayout(arg, Array.from([...((_a = idl.accounts) !== null && _a !== void 0 ? _a : []), ...((_b = idl.types) !== null && _b !== void 0 ? _b : [])]));\n      });\n      const name = camelCase(m.name);\n      return [name, borsh.struct(fieldLayouts, name)];\n    }).concat(idl.instructions.map(ix => {\n      let fieldLayouts = ix.args.map(arg => {\n        var _a, _b;\n        return IdlCoder.fieldLayout(arg, Array.from([...((_a = idl.accounts) !== null && _a !== void 0 ? _a : []), ...((_b = idl.types) !== null && _b !== void 0 ? _b : [])]));\n      });\n      const name = camelCase(ix.name);\n      return [name, borsh.struct(fieldLayouts, name)];\n    }));\n    // @ts-ignore\n    return new Map(ixLayouts);\n  }\n  /**\n   * Dewcodes a program instruction.\n   */\n  decode(ix) {\n    let encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"hex\";\n    if (typeof ix === \"string\") {\n      ix = encoding === \"hex\" ? Buffer.from(ix, \"hex\") : bs58.decode(ix);\n    }\n    let sighash = bs58.encode(ix.slice(0, 8));\n    let data = ix.slice(8);\n    const decoder = this.sighashLayouts.get(sighash);\n    if (!decoder) {\n      return null;\n    }\n    return {\n      data: decoder.layout.decode(data),\n      name: decoder.name\n    };\n  }\n  /**\n   * Returns a formatted table of all the fields in the given instruction data.\n   */\n  format(ix, accountMetas) {\n    return InstructionFormatter.format(ix, accountMetas, this.idl);\n  }\n}\nclass InstructionFormatter {\n  static format(ix, accountMetas, idl) {\n    const idlIx = idl.instructions.filter(i => ix.name === i.name)[0];\n    if (idlIx === undefined) {\n      console.error(\"Invalid instruction given\");\n      return null;\n    }\n    const args = idlIx.args.map(idlField => {\n      return {\n        name: idlField.name,\n        type: InstructionFormatter.formatIdlType(idlField.type),\n        data: InstructionFormatter.formatIdlData(idlField, ix.data[idlField.name], idl.types)\n      };\n    });\n    const flatIdlAccounts = InstructionFormatter.flattenIdlAccounts(idlIx.accounts);\n    const accounts = accountMetas.map((meta, idx) => {\n      if (idx < flatIdlAccounts.length) {\n        return {\n          name: flatIdlAccounts[idx].name,\n          ...meta\n        };\n      }\n      // \"Remaining accounts\" are unnamed in Anchor.\n      else {\n        return {\n          name: undefined,\n          ...meta\n        };\n      }\n    });\n    return {\n      args,\n      accounts\n    };\n  }\n  static formatIdlType(idlType) {\n    if (typeof idlType === \"string\") {\n      return idlType;\n    }\n    if (\"vec\" in idlType) {\n      return `Vec<${this.formatIdlType(idlType.vec)}>`;\n    }\n    if (\"option\" in idlType) {\n      return `Option<${this.formatIdlType(idlType.option)}>`;\n    }\n    if (\"defined\" in idlType) {\n      return idlType.defined;\n    }\n    if (\"array\" in idlType) {\n      return `Array<${idlType.array[0]}; ${idlType.array[1]}>`;\n    }\n    throw new Error(`Unknown IDL type: ${idlType}`);\n  }\n  static formatIdlData(idlField, data, types) {\n    if (typeof idlField.type === \"string\") {\n      return data.toString();\n    }\n    // @ts-ignore\n    if (idlField.type.vec) {\n      // @ts-ignore\n      return \"[\" + data\n      // @ts-ignore\n      .map(d => this.formatIdlData(\n      // @ts-ignore\n      {\n        name: \"\",\n        type: idlField.type.vec\n      }, d)).join(\", \") + \"]\";\n    }\n    // @ts-ignore\n    if (idlField.type.option) {\n      // @ts-ignore\n      return data === null ? \"null\" : this.formatIdlData(\n      // @ts-ignore\n      {\n        name: \"\",\n        type: idlField.type.option\n      }, data);\n    }\n    // @ts-ignore\n    if (idlField.type.defined) {\n      if (types === undefined) {\n        throw new Error(\"User defined types not provided\");\n      }\n      // @ts-ignore\n      const filtered = types.filter(t => t.name === idlField.type.defined);\n      if (filtered.length !== 1) {\n        // @ts-ignore\n        throw new Error(`Type not found: ${idlField.type.defined}`);\n      }\n      return InstructionFormatter.formatIdlDataDefined(filtered[0], data, types);\n    }\n    return \"unknown\";\n  }\n  static formatIdlDataDefined(typeDef, data, types) {\n    if (typeDef.type.kind === \"struct\") {\n      const struct = typeDef.type;\n      const fields = Object.keys(data).map(k => {\n        const f = struct.fields.filter(f => f.name === k)[0];\n        if (f === undefined) {\n          throw new Error(\"Unable to find type\");\n        }\n        return k + \": \" + InstructionFormatter.formatIdlData(f, data[k], types);\n      }).join(\", \");\n      return \"{ \" + fields + \" }\";\n    } else {\n      if (typeDef.type.variants.length === 0) {\n        return \"{}\";\n      }\n      // Struct enum.\n      if (typeDef.type.variants[0].name) {\n        const variants = typeDef.type.variants;\n        const variant = Object.keys(data)[0];\n        const enumType = data[variant];\n        const namedFields = Object.keys(enumType).map(f => {\n          var _a;\n          const fieldData = enumType[f];\n          const idlField = (_a = variants[variant]) === null || _a === void 0 ? void 0 : _a.filter(v => v.name === f)[0];\n          if (idlField === undefined) {\n            throw new Error(\"Unable to find variant\");\n          }\n          return f + \": \" + InstructionFormatter.formatIdlData(idlField, fieldData, types);\n        }).join(\", \");\n        const variantName = camelCase(variant, {\n          pascalCase: true\n        });\n        if (namedFields.length === 0) {\n          return variantName;\n        }\n        return `${variantName} { ${namedFields} }`;\n      }\n      // Tuple enum.\n      else {\n        // TODO.\n        return \"Tuple formatting not yet implemented\";\n      }\n    }\n  }\n  static flattenIdlAccounts(accounts, prefix) {\n    // @ts-ignore\n    return accounts.map(account => {\n      const accName = sentenceCase(account.name);\n      // @ts-ignore\n      if (account.accounts) {\n        const newPrefix = prefix ? `${prefix} > ${accName}` : accName;\n        // @ts-ignore\n        return InstructionFormatter.flattenIdlAccounts(\n        // @ts-ignore\n        account.accounts, newPrefix);\n      } else {\n        return {\n          ...account,\n          name: prefix ? `${prefix} > ${accName}` : accName\n        };\n      }\n    }).flat();\n  }\n}\nfunction sentenceCase(field) {\n  const result = field.replace(/([A-Z])/g, \" $1\");\n  return result.charAt(0).toUpperCase() + result.slice(1);\n}","map":{"version":3,"mappings":"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","names":["camelCase","borsh","bs58","IdlCoder","sighash","SIGHASH_STATE_NAMESPACE","SIGHASH_GLOBAL_NAMESPACE","InstructionCoder","constructor","idl","ixLayout","parseIxLayout","sighashLayouts","Map","instructions","forEach","ix","sh","name","set","encode","layout","get","state","methods","map","ixName","_encode","encodeState","nameSpace","buffer","Buffer","alloc","methodName","Error","len","data","slice","concat","stateMethods","ixLayouts","m","fieldLayouts","args","arg","fieldLayout","Array","from","accounts","types","struct","decode","encoding","decoder","format","accountMetas","InstructionFormatter","idlIx","filter","i","undefined","console","error","idlField","type","formatIdlType","formatIdlData","flatIdlAccounts","flattenIdlAccounts","meta","idx","length","idlType","vec","option","defined","array","toString","d","join","filtered","t","formatIdlDataDefined","typeDef","kind","fields","Object","keys","k","f","variants","variant","enumType","namedFields","fieldData","v","variantName","pascalCase","prefix","account","accName","sentenceCase","newPrefix","flat","field","result","replace","charAt","toUpperCase"],"sourceRoot":"","sources":["../../../src/coder/instruction.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}