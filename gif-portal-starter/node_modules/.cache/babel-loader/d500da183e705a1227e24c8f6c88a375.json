{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Program = void 0;\nconst pako_1 = require(\"pako\");\nconst provider_js_1 = require(\"../provider.js\");\nconst idl_js_1 = require(\"../idl.js\");\nconst index_js_1 = require(\"../coder/index.js\");\nconst index_js_2 = __importDefault(require(\"./namespace/index.js\"));\nconst index_js_3 = require(\"../utils/bytes/index.js\");\nconst event_js_1 = require(\"./event.js\");\nconst common_js_1 = require(\"./common.js\");\n__exportStar(require(\"./common.js\"), exports);\n__exportStar(require(\"./context.js\"), exports);\n__exportStar(require(\"./event.js\"), exports);\n__exportStar(require(\"./namespace/index.js\"), exports);\n/**\n * ## Program\n *\n * Program provides the IDL deserialized client representation of an Anchor\n * program.\n *\n * This API is the one stop shop for all things related to communicating with\n * on-chain programs. Among other things, one can send transactions, fetch\n * deserialized accounts, decode instruction data, subscribe to account\n * changes, and listen to events.\n *\n * In addition to field accessors and methods, the object provides a set of\n * dynamically generated properties, also known as namespaces, that\n * map one-to-one to program methods and accounts. These namespaces generally\n *  can be used as follows:\n *\n * ## Usage\n *\n * ```javascript\n * program.<namespace>.<program-specific-method>\n * ```\n *\n * API specifics are namespace dependent. The examples used in the documentation\n * below will refer to the two counter examples found\n * [here](https://github.com/coral-xyz/anchor#examples).\n */\nclass Program {\n  /**\n   * @param idl       The interface definition.\n   * @param programId The on-chain address of the program.\n   * @param provider  The network and wallet context to use. If not provided\n   *                  then uses [[getProvider]].\n   */\n  constructor(idl, programId, provider, coder) {\n    programId = (0, common_js_1.translateAddress)(programId);\n    if (!provider) {\n      provider = (0, provider_js_1.getProvider)();\n    }\n    // Fields.\n    this._idl = idl;\n    this._provider = provider;\n    this._programId = programId;\n    this._coder = coder !== null && coder !== void 0 ? coder : new index_js_1.BorshCoder(idl);\n    this._events = new event_js_1.EventManager(this._programId, provider, this._coder);\n    // Dynamic namespaces.\n    const [rpc, instruction, transaction, account, simulate, methods, state, views] = index_js_2.default.build(idl, this._coder, programId, provider);\n    this.rpc = rpc;\n    this.instruction = instruction;\n    this.transaction = transaction;\n    this.account = account;\n    this.simulate = simulate;\n    this.methods = methods;\n    this.state = state;\n    this.views = views;\n  }\n  /**\n   * Address of the program.\n   */\n  get programId() {\n    return this._programId;\n  }\n  /**\n   * IDL defining the program's interface.\n   */\n  get idl() {\n    return this._idl;\n  }\n  /**\n   * Coder for serializing requests.\n   */\n  get coder() {\n    return this._coder;\n  }\n  /**\n   * Wallet and network provider.\n   */\n  get provider() {\n    return this._provider;\n  }\n  /**\n   * Generates a Program client by fetching the IDL from the network.\n   *\n   * In order to use this method, an IDL must have been previously initialized\n   * via the anchor CLI's `anchor idl init` command.\n   *\n   * @param programId The on-chain address of the program.\n   * @param provider  The network and wallet context.\n   */\n  static async at(address, provider) {\n    const programId = (0, common_js_1.translateAddress)(address);\n    const idl = await Program.fetchIdl(programId, provider);\n    if (!idl) {\n      throw new Error(`IDL not found for program: ${address.toString()}`);\n    }\n    return new Program(idl, programId, provider);\n  }\n  /**\n   * Fetches an idl from the blockchain.\n   *\n   * In order to use this method, an IDL must have been previously initialized\n   * via the anchor CLI's `anchor idl init` command.\n   *\n   * @param programId The on-chain address of the program.\n   * @param provider  The network and wallet context.\n   */\n  static async fetchIdl(address, provider) {\n    provider = provider !== null && provider !== void 0 ? provider : (0, provider_js_1.getProvider)();\n    const programId = (0, common_js_1.translateAddress)(address);\n    const idlAddr = await (0, idl_js_1.idlAddress)(programId);\n    const accountInfo = await provider.connection.getAccountInfo(idlAddr);\n    if (!accountInfo) {\n      return null;\n    }\n    // Chop off account discriminator.\n    let idlAccount = (0, idl_js_1.decodeIdlAccount)(accountInfo.data.slice(8));\n    const inflatedIdl = (0, pako_1.inflate)(idlAccount.data);\n    return JSON.parse(index_js_3.utf8.decode(inflatedIdl));\n  }\n  /**\n   * Invokes the given callback every time the given event is emitted.\n   *\n   * @param eventName The PascalCase name of the event, provided by the IDL.\n   * @param callback  The function to invoke whenever the event is emitted from\n   *                  program logs.\n   */\n  addEventListener(eventName, callback) {\n    return this._events.addEventListener(eventName, callback);\n  }\n  /**\n   * Unsubscribes from the given eventName.\n   */\n  async removeEventListener(listener) {\n    return await this._events.removeEventListener(listener);\n  }\n}\nexports.Program = Program;","map":{"version":3,"mappings":"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","names":["__exportStar","Program","constructor","idl","programId","provider","coder","_idl","_provider","_programId","_coder","index_js_1","_events","event_js_1","rpc","instruction","transaction","account","simulate","methods","state","views","index_js_2","build","at","address","fetchIdl","Error","toString","idlAddr","accountInfo","connection","getAccountInfo","idlAccount","data","slice","inflatedIdl","JSON","parse","index_js_3","decode","addEventListener","eventName","callback","removeEventListener","listener","exports"],"sourceRoot":"","sources":["../../../src/program/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}