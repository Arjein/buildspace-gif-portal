{"ast":null,"code":"import BN from \"bn.js\";\nimport { sha256 as sha256Sync } from \"js-sha256\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { translateAddress } from \"../program/common\";\n// Sync version of web3.PublicKey.createWithSeed.\nexport function createWithSeedSync(fromPublicKey, seed, programId) {\n  const buffer = Buffer.concat([fromPublicKey.toBuffer(), Buffer.from(seed), programId.toBuffer()]);\n  const hash = sha256Sync.digest(buffer);\n  return new PublicKey(Buffer.from(hash));\n}\n// Sync version of web3.PublicKey.createProgramAddress.\nexport function createProgramAddressSync(seeds, programId) {\n  const MAX_SEED_LENGTH = 32;\n  let buffer = Buffer.alloc(0);\n  seeds.forEach(function (seed) {\n    if (seed.length > MAX_SEED_LENGTH) {\n      throw new TypeError(`Max seed length exceeded`);\n    }\n    buffer = Buffer.concat([buffer, toBuffer(seed)]);\n  });\n  buffer = Buffer.concat([buffer, programId.toBuffer(), Buffer.from(\"ProgramDerivedAddress\")]);\n  let hash = sha256Sync(new Uint8Array(buffer));\n  let publicKeyBytes = new BN(hash, 16).toArray(undefined, 32);\n  if (PublicKey.isOnCurve(new Uint8Array(publicKeyBytes))) {\n    throw new Error(`Invalid seeds, address must fall off the curve`);\n  }\n  return new PublicKey(publicKeyBytes);\n}\n// Sync version of web3.PublicKey.findProgramAddress.\nexport function findProgramAddressSync(seeds, programId) {\n  let nonce = 255;\n  let address;\n  while (nonce != 0) {\n    try {\n      const seedsWithNonce = seeds.concat(Buffer.from([nonce]));\n      address = createProgramAddressSync(seedsWithNonce, programId);\n    } catch (err) {\n      if (err instanceof TypeError) {\n        throw err;\n      }\n      nonce--;\n      continue;\n    }\n    return [address, nonce];\n  }\n  throw new Error(`Unable to find a viable program address nonce`);\n}\nconst toBuffer = arr => {\n  if (arr instanceof Buffer) {\n    return arr;\n  } else if (arr instanceof Uint8Array) {\n    return Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);\n  } else {\n    return Buffer.from(arr);\n  }\n};\nexport async function associated(programId) {\n  let seeds = [Buffer.from([97, 110, 99, 104, 111, 114])]; // b\"anchor\".\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n  args.forEach(arg => {\n    seeds.push(\n    // @ts-ignore\n    arg.buffer !== undefined ? arg : translateAddress(arg).toBuffer());\n  });\n  const [assoc] = await PublicKey.findProgramAddress(seeds, translateAddress(programId));\n  return assoc;\n}","map":{"version":3,"mappings":"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","names":["BN","sha256","sha256Sync","PublicKey","translateAddress","createWithSeedSync","fromPublicKey","seed","programId","buffer","Buffer","concat","toBuffer","from","hash","digest","createProgramAddressSync","seeds","MAX_SEED_LENGTH","alloc","forEach","length","TypeError","Uint8Array","publicKeyBytes","toArray","undefined","isOnCurve","Error","findProgramAddressSync","nonce","address","seedsWithNonce","err","arr","byteOffset","byteLength","associated","args","arg","push","assoc","findProgramAddress"],"sourceRoot":"","sources":["../../../src/utils/pubkey.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}