{"ast":null,"code":"import * as assert from \"assert\";\nconst LOG_START_INDEX = \"Program log: \".length;\nexport class EventManager {\n  constructor(programId, provider, coder) {\n    this._programId = programId;\n    this._provider = provider;\n    this._eventParser = new EventParser(programId, coder);\n    this._eventCallbacks = new Map();\n    this._eventListeners = new Map();\n    this._listenerIdCount = 0;\n  }\n  addEventListener(eventName, callback) {\n    var _a;\n    let listener = this._listenerIdCount;\n    this._listenerIdCount += 1;\n    // Store the listener into the event map.\n    if (!(eventName in this._eventCallbacks)) {\n      this._eventListeners.set(eventName, []);\n    }\n    this._eventListeners.set(eventName, ((_a = this._eventListeners.get(eventName)) !== null && _a !== void 0 ? _a : []).concat(listener));\n    // Store the callback into the listener map.\n    this._eventCallbacks.set(listener, [eventName, callback]);\n    // Create the subscription singleton, if needed.\n    if (this._onLogsSubscriptionId !== undefined) {\n      return listener;\n    }\n    this._onLogsSubscriptionId = this._provider.connection.onLogs(this._programId, (logs, ctx) => {\n      if (logs.err) {\n        console.error(logs);\n        return;\n      }\n      this._eventParser.parseLogs(logs.logs, event => {\n        const allListeners = this._eventListeners.get(event.name);\n        if (allListeners) {\n          allListeners.forEach(listener => {\n            const listenerCb = this._eventCallbacks.get(listener);\n            if (listenerCb) {\n              const [, callback] = listenerCb;\n              callback(event.data, ctx.slot);\n            }\n          });\n        }\n      });\n    });\n    return listener;\n  }\n  async removeEventListener(listener) {\n    // Get the callback.\n    const callback = this._eventCallbacks.get(listener);\n    if (!callback) {\n      throw new Error(`Event listener ${listener} doesn't exist!`);\n    }\n    const [eventName] = callback;\n    // Get the listeners.\n    let listeners = this._eventListeners.get(eventName);\n    if (!listeners) {\n      throw new Error(`Event listeners don't exist for ${eventName}!`);\n    }\n    // Update both maps.\n    this._eventCallbacks.delete(listener);\n    listeners = listeners.filter(l => l !== listener);\n    if (listeners.length === 0) {\n      this._eventListeners.delete(eventName);\n    }\n    // Kill the websocket connection if all listeners have been removed.\n    if (this._eventCallbacks.size == 0) {\n      assert.ok(this._eventListeners.size === 0);\n      if (this._onLogsSubscriptionId !== undefined) {\n        await this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId);\n        this._onLogsSubscriptionId = undefined;\n      }\n    }\n  }\n}\nexport class EventParser {\n  constructor(programId, coder) {\n    this.coder = coder;\n    this.programId = programId;\n  }\n  // Each log given, represents an array of messages emitted by\n  // a single transaction, which can execute many different programs across\n  // CPI boundaries. However, the subscription is only interested in the\n  // events emitted by *this* program. In achieving this, we keep track of the\n  // program execution context by parsing each log and looking for a CPI\n  // `invoke` call. If one exists, we know a new program is executing. So we\n  // push the programId onto a stack and switch the program context. This\n  // allows us to track, for a given log, which program was executing during\n  // its emission, thereby allowing us to know if a given log event was\n  // emitted by *this* program. If it was, then we parse the raw string and\n  // emit the event if the string matches the event being subscribed to.\n  parseLogs(logs, callback) {\n    const logScanner = new LogScanner(logs);\n    const execution = new ExecutionContext(logScanner.next());\n    let log = logScanner.next();\n    while (log !== null) {\n      let [event, newProgram, didPop] = this.handleLog(execution, log);\n      if (event) {\n        callback(event);\n      }\n      if (newProgram) {\n        execution.push(newProgram);\n      }\n      if (didPop) {\n        execution.pop();\n      }\n      log = logScanner.next();\n    }\n  }\n  // Main log handler. Returns a three element array of the event, the\n  // next program that was invoked for CPI, and a boolean indicating if\n  // a program has completed execution (and thus should be popped off the\n  // execution stack).\n  handleLog(execution, log) {\n    // Executing program is this program.\n    if (execution.stack.length > 0 && execution.program() === this.programId.toString()) {\n      return this.handleProgramLog(log);\n    }\n    // Executing program is not this program.\n    else {\n      return [null, ...this.handleSystemLog(log)];\n    }\n  }\n  // Handles logs from *this* program.\n  handleProgramLog(log) {\n    // This is a `msg!` log.\n    if (log.startsWith(\"Program log:\")) {\n      const logStr = log.slice(LOG_START_INDEX);\n      const event = this.coder.events.decode(logStr);\n      return [event, null, false];\n    }\n    // System log.\n    else {\n      return [null, ...this.handleSystemLog(log)];\n    }\n  }\n  // Handles logs when the current program being executing is *not* this.\n  handleSystemLog(log) {\n    // System component.\n    const logStart = log.split(\":\")[0];\n    // Did the program finish executing?\n    if (logStart.match(/^Program (.*) success/g) !== null) {\n      return [null, true];\n      // Recursive call.\n    } else if (logStart.startsWith(`Program ${this.programId.toString()} invoke`)) {\n      return [this.programId.toString(), false];\n    }\n    // CPI call.\n    else if (logStart.includes(\"invoke\")) {\n      return [\"cpi\", false]; // Any string will do.\n    } else {\n      return [null, false];\n    }\n  }\n}\n// Stack frame execution context, allowing one to track what program is\n// executing for a given log.\nclass ExecutionContext {\n  constructor(log) {\n    var _a;\n    // Assumes the first log in every transaction is an `invoke` log from the\n    // runtime.\n    const program = (_a = /^Program (.*) invoke.*$/g.exec(log)) === null || _a === void 0 ? void 0 : _a[1];\n    if (!program) {\n      throw new Error(`Could not find program invocation log line`);\n    }\n    this.stack = [program];\n  }\n  program() {\n    assert.ok(this.stack.length > 0);\n    return this.stack[this.stack.length - 1];\n  }\n  push(newProgram) {\n    this.stack.push(newProgram);\n  }\n  pop() {\n    assert.ok(this.stack.length > 0);\n    this.stack.pop();\n  }\n}\nclass LogScanner {\n  constructor(logs) {\n    this.logs = logs;\n  }\n  next() {\n    if (this.logs.length === 0) {\n      return null;\n    }\n    let l = this.logs[0];\n    this.logs = this.logs.slice(1);\n    return l;\n  }\n}","map":{"version":3,"mappings":"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","names":["assert","LOG_START_INDEX","length","EventManager","constructor","programId","provider","coder","_programId","_provider","_eventParser","EventParser","_eventCallbacks","Map","_eventListeners","_listenerIdCount","addEventListener","eventName","callback","listener","set","get","concat","_onLogsSubscriptionId","undefined","connection","onLogs","logs","ctx","err","console","error","parseLogs","event","allListeners","name","forEach","listenerCb","data","slot","removeEventListener","Error","listeners","delete","filter","l","size","ok","removeOnLogsListener","logScanner","LogScanner","execution","ExecutionContext","next","log","newProgram","didPop","handleLog","push","pop","stack","program","toString","handleProgramLog","handleSystemLog","startsWith","logStr","slice","events","decode","logStart","split","match","includes","exec"],"sourceRoot":"","sources":["../../../src/program/event.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}